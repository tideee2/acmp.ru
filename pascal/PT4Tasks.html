<!-- Programming Taskbook 4.8 | Copyright (c) M. Abramyan, 1998-2009 -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
<title>PT4Tasks</title>
<style type="text/css">
H1{font-family:"Arial";font-size:20pt;text-indent:0px;margin-top:10px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
H2{font-family:"Arial";font-size:16pt;text-indent:0px;margin-top:5px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
P{font-family:"Times New Roman";text-align:left;font-size:12pt;text-indent:0px;margin-top:0px; margin-right:10px; margin-bottom:0px; margin-left:10px;}
TD{font-family:"Times New Roman";font-size:12pt;}
LI{font-family:"Times New Roman";font-size:12pt;}
UL{font-family:"Times New Roman";font-size:12pt;}
SUB{font-family:"Times New Roman";font-size:8pt;}
SUP{font-family:"Times New Roman";font-size:8pt;}
TABLE{margin-top:0px; margin-bottom:0px;}
P.ptAuthor{text-align:right;font-size:10pt;font-style:italic;}
P.ptTask{text-align:justify;text-indent:-50px;margin-top:5px; margin-left:60px;}
P.ptTaskQuote{text-align:left;margin-left:120px;margin-top:0px;margin-bottom:0px;}
P.ptTaskCenter{text-align:center;margin-left:60px;margin-top:0px;margin-bottom:0px;}
P.ptTaskContinue{text-align:justify;margin-left:60px;}
P.ptComment{text-align:justify;text-indent:50px;margin-top:5px;}
P.ptCommentCenter{text-align:center;}
P.ptCommentQuote{text-align:left;margin-left:120px;margin-top:0px;margin-bottom:0px;}
P.ptCommentContinue{text-align:justify;}
P.ptFooter{text-align:right;font-size:10pt;font-style:italic;margin-right:0px;}
SPAN.ptSpecial{font-family:"Arial";}
PRE{font-family:"Courier New";text-align:left;font-size:10pt;text-indent:0px;margin-top:5px; margin-right:10px; margin-bottom:0px; margin-left:60px;}
CODE{font-size:10pt;}
P.ptPicture{font-family:Arial, sans-serif;margin-top: 5px;margin-bottom: 5px;margin-left: 60px;font-size: small;color: #000080;text-indent: 0pt;text-align: justify}
</style>
</head><body>
<h1>Деревья (с&nbsp;применением объектов и&nbsp;сборщика мусора)</h1>
<p class="ptAuthor">Автор: М.&nbsp;Э.&nbsp;Абрамян, 2008, 2012</p>
<p class="ptComment"> Все числа, используемые в заданиях на деревья, являются <i>целыми</i>. Все объекты имеют тип Node, который определен в задачнике Programming Taskbook. В заданиях на деревья у объектов типа Node используются свойства Data, Left, Right и Parent, поэтому при выполнении заданий можно считать, что класс Node включает следующие открытые свойства и методы: </p><p class="ptCommentQuote"><i>//Конструкторы</i>:<br> &nbsp; &nbsp;<tt>constructor Create;</tt><br> &nbsp; &nbsp;<tt>constructor Create(aData: integer);</tt><br> &nbsp; &nbsp;<tt>constructor Create(aLeft, aRight: Node; aData: integer);</tt><br> &nbsp; &nbsp;<tt>constructor Create(aLeft, aRight: Node; aData: integer; aParent: Node);</tt><br><i>//Свойства (доступны для чтения и для записи)</i>:<br> &nbsp; &nbsp;<tt>property Data: integer;</tt><br> &nbsp; &nbsp;<tt>property Left: Node;</tt><br> &nbsp; &nbsp;<tt>property Right: Node;</tt><br> &nbsp; &nbsp;<tt>property Parent: Node;</tt></p><p class="ptCommentContinue"></p><p class="ptComment">В большинстве заданий при работе с объектами типа Node требуются только свойства Data, Left и Right; свойство Parent используется лишь в заданиях на обработку дереьев с обратной связью. </p><p class="ptComment"><i>Значением</i> вершины дерева (т.&nbsp;е. объекта типа Node) считается значение ее свойства Data. </p><p class="ptComment">Так как в языке PascalABC.NET принята ссылочная объектная модель, т.&nbsp;е. любая переменная объектного типа является <i>ссылкой</i> на ту область памяти, в которой фактически размещен данный объект, выражение &#171;вывести ссылку на вершину дерева&#187; в формулировках заданий всегда означает, что требуется вывести значение переменной типа Node, связанной с этой вершиной. </p><p class="ptComment">В заданиях данной группы (в отличие от заданий группы ObjTree) при удалении вершины дерева не требуется освобождать связанные с ней ресурсы, поскольку предполагается, что эти ресурсы освобождаются автоматически, с применением специальной системы&nbsp;&#8212; <i>сборщика мусора</i> (англ. Garbage Collector, GC).</p>
<h2>Анализ бинарного дерева</h2>
<p class="ptTask"><span class="ptSpecial">GCTree1</span>. Дан объект <i>A</i><sub>1</sub> типа Node, имеющий открытые свойства Data (целого типа), Left и Right (типа Node). Свойства Left и Right этого объекта (<i>корня дерева</i>) содержат ссылки на левую и правую <i>дочерние вершины</i> (того же типа Node). Вывести значения свойств Data корня, его левой и правой дочерних вершин, а также ссылки на левую и правую дочерние вершины в указанном порядке. </p>
<p class="ptTask"><span class="ptSpecial">GCTree2°</span>. Дан объект <i>A</i><sub>1</sub> типа Node &#8212; корень дерева. Эта объект связан свойствами Left и Right с другими объектами того же типа (дочерними вершинами), они, в свою очередь, &#8212; со своими дочерними вершинами, и так далее до объектов, свойства Left и Right которых равны nil (у некоторых вершин может быть равно nil одно из свойств &#8212; Left или Right). Вывести количество вершин дерева. </p>
<p class="ptTask"><span class="ptSpecial">GCTree3</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева и число&nbsp;<i>K</i>. Вывести количество вершин дерева, значение которых равно&nbsp;<i>K</i>. </p>
<p class="ptTask"><span class="ptSpecial">GCTree4</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Вывести сумму значений всех вершин данного дерева. </p>
<p class="ptTask"><span class="ptSpecial">GCTree5</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Вывести количество вершин дерева, являющихся левыми дочерними вершинами (корень дерева не учитывать). </p>
<p class="ptTask"><span class="ptSpecial">GCTree6°</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. <i>Листом дерева</i> называется его вершина, не имеющая дочерних вершин. Вывести количество листьев для данного дерева. </p>
<p class="ptTask"><span class="ptSpecial">GCTree7</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Вывести сумму значений всех листьев данного дерева. </p>
<p class="ptTask"><span class="ptSpecial">GCTree8</span>. Дан корень <i>A</i><sub>1</sub> дерева, содержащего по крайней мере две вершины. Вывести количество листьев дерева, являющихся правыми дочерними вершинами. </p>
<p class="ptTask"><span class="ptSpecial">GCTree9°</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Считается, что корень дерева находится на <i>нулевом уровне</i>, его дочерние вершины &#8212; на <i>первом уровне</i> и т.&nbsp;д. Вывести <i>глубину дерева</i>, т.&nbsp;е. значение его максимального уровня (например, глубина дерева, состоящего только из корня, равна&nbsp;0). </p>
<p class="ptTask"><span class="ptSpecial">GCTree10</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Для каждого из уровней данного дерева, начиная с нулевого, вывести количество вершин, находящихся на этом уровне. Считать, что глубина дерева не превосходит&nbsp;10. </p>
<p class="ptTask"><span class="ptSpecial">GCTree11</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Для каждого из уровней данного дерева, начиная с нулевого, вывести сумму значений вершин, находящихся на этом уровне. Считать, что глубина дерева не превосходит&nbsp;10. </p>
<p class="ptTask"><span class="ptSpecial">GCTree12°</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Вывести значения всех вершин дерева в <i>инфиксном порядке</i> (вначале выводится содержимое левого поддерева в инфиксном порядке, затем выводится значение корня, затем &#8212; содержимое правого поддерева в инфиксном порядке). </p>
<p class="ptTask"><span class="ptSpecial">GCTree13°</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Вывести значения всех вершин дерева в <i>префиксном порядке</i> (вначале выводится значение корня, затем содержимое левого поддерева в префиксном порядке, затем &#8212; содержимое правого поддерева в префиксном порядке). </p>
<p class="ptTask"><span class="ptSpecial">GCTree14</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Вывести значения всех вершин дерева в <i>постфиксном порядке</i> (вначале выводится содержимое левого поддерева в постфиксном порядке, затем &#8212; содержимое правого поддерева в постфиксном порядке, затем &#8212; значение корня). </p>
<p class="ptTask"><span class="ptSpecial">GCTree15</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева и число&nbsp;<i>N</i> (&gt;&nbsp;0), не превосходящее количество вершин в исходном дереве. Нумеруя вершины в инфиксном порядке (см. задание GCTree12, нумерация ведется от&nbsp;1), вывести значения всех вершин с порядковыми номерами от&nbsp;1 до&nbsp;<i>N</i>. </p>
<p class="ptTask"><span class="ptSpecial">GCTree16</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева и число&nbsp;<i>N</i> (&gt;&nbsp;0), не превосходящее количество вершин в исходном дереве. Нумеруя вершины в постфиксном порядке (см. задание GCTree14, нумерация ведется от&nbsp;1), вывести значения всех вершин с порядковыми номерами от&nbsp;<i>N</i> до максимального номера. </p>
<p class="ptTask"><span class="ptSpecial">GCTree17</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева и два числа <i>N</i><sub>1</sub>, <i>N</i><sub>2</sub> (0&nbsp;&lt;&nbsp;<i>N</i><sub>1</sub>&nbsp;&lt;&nbsp;<i>N</i><sub>2</sub>), которые не превосходят количество вершин в исходном дереве. Нумеруя вершины в префиксном порядке (см. задание GCTree13, нумерация ведется от&nbsp;1), вывести значения всех вершин с порядковыми номерами от&nbsp;<i>N</i><sub>1</sub> до&nbsp;<i>N</i><sub>2</sub>. </p>
<p class="ptTask"><span class="ptSpecial">GCTree18</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева и неотрицательное число&nbsp;<i>L</i>. Используя любой из описанных в заданиях GCTree12&#8722;GCTree14 способов обхода дерева, вывести значения всех вершин уровня&nbsp;<i>L</i>, а также их количество&nbsp;<i>N</i> (если дерево не содержит вершин уровня&nbsp;<i>L</i>, то вывести&nbsp;0). </p>
<p class="ptTask"><span class="ptSpecial">GCTree19</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Вывести максимальное из значений его вершин и количество вершин, имеющих это максимальное значение. </p>
<p class="ptTask"><span class="ptSpecial">GCTree20</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Вывести минимальное из значений всех его вершин и количество листьев, имеющих это минимальное значение (данное количество может быть равно&nbsp;0). </p>
<p class="ptTask"><span class="ptSpecial">GCTree21</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Вывести минимальное из значений его вершин, являющихся листьями. </p>
<p class="ptTask"><span class="ptSpecial">GCTree22</span>. Дан корень <i>A</i><sub>1</sub> дерева, содержащего по крайней мере две вершины. Вывести максимальное из значений его <i>внутренних вершин</i> (т.&nbsp;е. вершин, не являющихся листьями). </p>
<p class="ptTask"><span class="ptSpecial">GCTree23</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Вывести ссылку <i>A</i><sub>2</sub> на первую вершину дерева с минимальным значением (вершины перебирать в префиксном порядке). </p>
<p class="ptTask"><span class="ptSpecial">GCTree24</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Вывести ссылку <i>A</i><sub>2</sub> на последнюю вершину дерева с максимальным нечетным значением (вершины перебирать в инфиксном порядке). Если дерево не содержит вершин с нечетными значениями, то вывести nil. </p>
<h2>Формирование бинарного дерева</h2>
<p class="ptTask"><span class="ptSpecial">GCTree25</span>. Дано число&nbsp;<i>N</i> (&gt;&nbsp;0) и набор из <i>N</i>&nbsp;чисел. Создать дерево из <i>N</i>&nbsp;вершин, в котором каждая вершина (кроме корня) является правой дочерней вершиной. Каждой создаваемой вершине присваивать очередное значение из исходного набора. Вывести ссылку на корень созданного дерева. </p>
<p class="ptTask"><span class="ptSpecial">GCTree26</span>. Дано число&nbsp;<i>N</i> (&gt;&nbsp;0) и набор из <i>N</i>&nbsp;чисел. Создать дерево из <i>N</i>&nbsp;вершин, в котором каждая внутренняя вершина имеет только одну дочернюю вершину, причем правые и левые дочерние вершины чередуются (корень имеет левую дочернюю вершину). Каждой создаваемой вершине присваивать очередное значение из исходного набора. Вывести ссылку на корень созданного дерева. </p>
<p class="ptTask"><span class="ptSpecial">GCTree27</span>. Дано число&nbsp;<i>N</i> (&gt;&nbsp;0) и набор из <i>N</i>&nbsp;чисел. Создать дерево из <i>N</i>&nbsp;вершин, в котором каждая внутренняя вершина имеет только одну дочернюю вершину, причем если значение вершины является нечетным, то она имеет левую дочернюю вершину, а если четным, то правую. Каждой создаваемой вершине присваивать очередное значение из исходного набора. Вывести ссылку на корень созданного дерева. </p>
<p class="ptTask"><span class="ptSpecial">GCTree28</span>. Дано четное число&nbsp;<i>N</i> (&gt;&nbsp;0) и набор из <i>N</i>&nbsp;чисел. Создать дерево из <i>N</i>&nbsp;вершин, в котором каждая левая дочерняя вершина является листом, а правая дочерняя вершина является внутренней. Для каждой внутренней вершины вначале создавать левую дочернюю вершину, а затем правую (если она существует); каждой создаваемой вершине присваивать очередное значение из исходного набора. Вывести ссылку на корень созданного дерева. </p>
<p class="ptTask"><span class="ptSpecial">GCTree29</span>. Дано четное число&nbsp;<i>N</i> (&gt;&nbsp;0) и набор из <i>N</i>&nbsp;чисел. Создать дерево из <i>N</i>&nbsp;вершин со следующей структурой: если вершина дерева является внутренней, то в случае, если она имеет нечетное значение, ее левая дочерняя вершина должна быть листом, а в случае, если она имеет четное значение, листом должна быть ее правая вершина. Для каждой внутренней вершины вначале создавать дочернюю вершину-лист, а затем дочернюю внутреннюю вершину (если данная вершина существует); каждой создаваемой вершине присваивать очередное значение из исходного набора. Вывести ссылку на корень созданного дерева. </p>
<p class="ptTask"><span class="ptSpecial">GCTree30</span>. Дано число&nbsp;<i>N</i> (&gt;&nbsp;0). Создать дерево, корень которого имеет значение&nbsp;<i>N</i>, а вершины обладают следующими свойствами: вершина с четным значением&nbsp;<i>K</i> имеет левую дочернюю вершину со значением&nbsp;<i>K</i>/2 и не имеет правой дочерней вершины; вершина со значением 1 является листом; вершина с любым другим нечетным значением&nbsp;<i>K</i> имеет две дочерние вершины: левую со значением <i>K</i>/2 и правую со значением <i>K</i>&nbsp;&#8722;&nbsp;<i>K</i>/2 (символ &#171;/&#187; обозначает операцию деления нацело). Вывести ссылку на корень созданного дерева. </p>
<p class="ptTask"><span class="ptSpecial">GCTree31</span>. Даны положительные числа <i>L</i>, <i>N</i> (<i>N</i>&nbsp;&gt;&nbsp;<i>L</i>) и набор из <i>N</i>&nbsp;чисел. Создать дерево глубины&nbsp;<i>L</i>, содержащее вершины со значениями из исходного набора. Вершины добавлять к дереву в префиксном порядке, используя алгоритм, который для каждой вершины уровня, не превышающего&nbsp;<i>L</i>, вначале создает саму вершину с очередным значением из исходного набора, затем ее левое поддерево соответствующей глубины, а затем ее правое поддерево. Если для заполнения дерева глубины&nbsp;<i>L</i> требуется менее <i>N</i>&nbsp;вершин, то оставшиеся числа из исходного набора не использовать. Вывести ссылку на корень созданного дерева. </p>
<p class="ptTask"><span class="ptSpecial">GCTree32°</span>. Дано число&nbsp;<i>N</i> (&gt;&nbsp;0) и набор из <i>N</i>&nbsp;чисел. Создать <i>идеально сбалансированное дерево</i> из <i>N</i>&nbsp;вершин с заданными значениями (т.&nbsp;е. дерево, для каждой вершины которого количество вершин в его левом и правом поддереве отличается не более чем на&nbsp;1) и вывести ссылку на его корень. Для создания дерева использовать рекурсивный алгоритм, который создает вершину дерева с очередным значением, после чего вызывается для создания левого поддерева с <i>N</i>/2&nbsp;вершинами и правого поддерева с <i>N</i>&nbsp;&#8722;&nbsp;1&nbsp;&#8722;&nbsp;<i>N</i>/2 вершинами (символ &#171;/&#187; обозначает операцию деления нацело). </p>
<p class="ptTask"><span class="ptSpecial">GCTree33</span>. Дано число&nbsp;<i>N</i> (&gt;&nbsp;0). Создать идеально сбалансированное дерево из <i>N</i>&nbsp;вершин и вывести ссылку на его корень. Значение каждой вершины положить равным уровню этой вершины (например, корень дерева должен иметь значение&nbsp;0, его дочерние вершины &#8212; значение&nbsp;1 и т.&nbsp;д.). При формировании дерева использовать алгоритм, описанный в задании GCTree32. </p>
<p class="ptTask"><span class="ptSpecial">GCTree34°</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Создать копию данного дерева и вывести ссылку <i>A</i><sub>2</sub> на корень созданной копии. </p>
<h2>Преобразование бинарного дерева</h2>
<p class="ptTask"><span class="ptSpecial">GCTree35</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Удвоить значение каждой вершины дерева. </p>
<p class="ptTask"><span class="ptSpecial">GCTree36</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Для каждой вершины дерева с четным значением уменьшить ее значение в два раза. </p>
<p class="ptTask"><span class="ptSpecial">GCTree37</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Добавить&nbsp;1 к значению каждого листа дерева и вычесть&nbsp;1 из значения каждой внутренней вершины. </p>
<p class="ptTask"><span class="ptSpecial">GCTree38</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Для каждой вершины дерева, имеющей две дочерние вершины, поменять местами значения дочерних вершин (т.&nbsp;е. значения их свойств Data). </p>
<p class="ptTask"><span class="ptSpecial">GCTree39</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Для всех внутренних вершин дерева поменять местами их левые и правые дочерние вершины (т.&nbsp;е. значения свойств Left и Right). </p>
<p class="ptTask"><span class="ptSpecial">GCTree40°</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Удалить из дерева все вершины, кроме корня (свойствам Left и Right корня следует присвоить значение nil). </p>
<p class="ptTask"><span class="ptSpecial">GCTree41</span>. Дан корень <i>A</i><sub>1</sub> дерева, содержащего по крайней мере две вершины. Удалить каждую вершину дерева, являющуюся листом; при этом соответствующее свойство родительской вершины (Left или Right) следует положить равным nil. </p>
<p class="ptTask"><span class="ptSpecial">GCTree42</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Удалить вершины дерева, имеющие значения, меньшие значения корня, вместе со всеми их дочерними вершинами. </p>
<p class="ptTask"><span class="ptSpecial">GCTree43</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Для вершин дерева, имеющих две дочерние вершины, удалить одну из дочерних вершин: правую, если родительская вершина имеет четное значение, и левую в противном случае (вершины дерева перебирать в префиксном порядке, при удалении вершины удалять и всех ее потомков). </p>
<p class="ptTask"><span class="ptSpecial">GCTree44</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Ко всем вершинам дерева, которые являются листьями, добавить по две дочерние вершины-листа: левую со значением&nbsp;10 и правую со значением&nbsp;11. </p>
<p class="ptTask"><span class="ptSpecial">GCTree45</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Ко всем вершинам дерева, которые являются листьями, добавить по одной дочерней вершине-листу; при этом к исходной вершине с нечетным значением добавляется левая дочерняя вершина, а к вершине с четным значением &#8212; правая. Значение каждой добавленной вершины положить равным значению ее родительской вершины. </p>
<p class="ptTask"><span class="ptSpecial">GCTree46</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Ко всем вершинам дерева, которые содержат ровно по одной дочерней вершине, добавить еще одину дочернюю вершину-лист. Значение каждой добавленной вершины положить равным удвоенному значению ее родительской вершины. </p>
<p class="ptTask"><span class="ptSpecial">GCTree47°</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Не изменяя глубины&nbsp;<i>L</i> исходного дерева, дополнить его до <i>полного дерева</i>, т.&nbsp;е. дерева, у которого все внутренние вершины имеют по два непосредственных потомка, а все листья находятся на уровне&nbsp;<i>L</i>. Значения всех добавленных вершин положить равными&nbsp;&#8722;1. </p>
<h2>Бинарные деревья с&nbsp;обратной связью</h2>
<p class="ptTask"><span class="ptSpecial">GCTree48</span>. Дана вершина дерева <i>A</i><sub>1</sub> &#8212; объект типа Node, имеющий открытые свойства Data (целого типа), Left, Right и Parent (типа Node). Свойства Left и Right содержат ссылки на дочерние вершины, а свойство Parent &#8212; на родительскую вершину данной вершины (если вершина является корнем дерева, то ее свойство Parent равно nil). Для данной вершины вывести ссылки <i>A</i><sub><i>L</i></sub>, <i>A</i><sub><i>R</i></sub> и <i>A</i><sub>0</sub> на ее левую и правую дочерние вершины и родительскую вершину, а также ссылку <i>A</i><sub>2</sub> на ее <i>сестру</i>, т.&nbsp;е. другую вершину дерева, имеющую в качестве родительской вершину <i>A</i><sub>0</sub>. Если некоторые из перечисленных вершин не существуют, то вывести для них значение nil. </p>
<p class="ptTask"><span class="ptSpecial">GCTree49°</span>. Дан корень <i>A</i><sub>1</sub> дерева, вершинами которого являются объекты типа Node, связанные между собой с помощью свойств Left и Right. Используя свойство Parent объекта Node, преобразовать исходное дерево в <i>дерево с обратной связью</i>, в котором каждая вершина связана не только со своими дочерними вершинами (свойствами Left и Right), но и с родительской вершиной (свойством Parent). Свойство Parent корня дерева положить равным nil. </p>
<p class="ptTask"><span class="ptSpecial">GCTree50</span>. Дана ссылка <i>A</i><sub>1</sub> на одну из вершин дерева с обратной связью. Вывести ссылку <i>A</i><sub>2</sub> на корень исходного дерева. </p>
<p class="ptTask"><span class="ptSpecial">GCTree51</span>. Даны ссылки <i>A</i><sub>1</sub>, <i>A</i><sub>2</sub>, <i>A</i><sub>3</sub> на три вершины дерева с обратной связью. Для каждой из данных вершин вывести ее уровень (корень дерева имеет уровень&nbsp;0). </p>
<p class="ptTask"><span class="ptSpecial">GCTree52</span>. Даны ссылки <i>A</i><sub>1</sub> и <i>A</i><sub>2</sub> на две различные вершины дерева с обратной связью. Вывести <i>степень родства</i> вершины <i>A</i><sub>1</sub> по отношению к вершине <i>A</i><sub>2</sub> (степень родства равна &#8722;1, если вершина <i>A</i><sub>2</sub> не находится в цепочке предков для вершины <i>A</i><sub>1</sub>; в противном случае степень родства равна <i>L</i><sub>1</sub>&nbsp;&#8722;&nbsp;<i>L</i><sub>2</sub>, где <i>L</i><sub>1</sub> и <i>L</i><sub>2</sub> &#8212; уровни вершин <i>A</i><sub>1</sub> и <i>A</i><sub>2</sub> соответственно). </p>
<p class="ptTask"><span class="ptSpecial">GCTree53°</span>. Даны ссылки <i>A</i><sub>1</sub> и <i>A</i><sub>2</sub> на две различные вершины дерева с обратной связью. Вывести ссылку <i>A</i><sub>0</sub> на вершину дерева, являющуюся ближайшим общим предком вершин <i>A</i><sub>1</sub> и <i>A</i><sub>2</sub>. </p>
<p class="ptTask"><span class="ptSpecial">GCTree54</span>. Дана ссылка <i>A</i><sub>1</sub> на одну из вершин дерева с обратной связью. Создать копию данного дерева и вывести ссылку <i>A</i><sub>2</sub> на корень созданной копии. </p>
<p class="ptTask"><span class="ptSpecial">GCTree55</span>. Дана ссылка <i>A</i><sub>1</sub> на вершину дерева с обратной связью, которая не является корнем. Если вершина <i>A</i><sub>1</sub> имеет сестру, то удалить эту сестру вместе со всеми ее потомками (и вызвать для них метод Dispose); если вершина <i>A</i><sub>1</sub> не имеет сестры, то создать сестру и всех ее потомков в виде копии поддерева с корнем <i>A</i><sub>1</sub>. Вывести ссылку <i>A</i><sub>0</sub> на родительскую вершину вершины <i>A</i><sub>1</sub>. </p>
<p class="ptTask"><span class="ptSpecial">GCTree56</span>. Даны положительные числа <i>L</i>, <i>N</i> (<i>N</i>&nbsp;&gt;&nbsp;<i>L</i>) и набор из <i>N</i>&nbsp;чисел. Сформировать дерево глубины&nbsp;<i>L</i> с обратной связью, содержащее вершины со значениями из исходного набора. Вершины добавлять к дереву в префиксном порядке, используя алгоритм, который для каждой вершины уровня, не превышающего&nbsp;<i>L</i>, вначале создает саму вершину с очередным значением из исходного набора, затем ее левое поддерево соответствующей глубины, а затем ее правое поддерево. Если для заполнения дерева глубины&nbsp;<i>L</i> требуется менее <i>N</i>&nbsp;вершин, то оставшиеся числа из исходного набора не использовать. Вывести ссылку на корень созданного дерева. </p>
<h2>Бинарные деревья поиска</h2>
<p class="ptTask"><span class="ptSpecial">GCTree57</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Если данное дерево является <i>деревом поиска</i>, т.&nbsp;е. если при обходе его вершин в инфиксном порядке их значения образуют неубывающую последовательность, то вывести nil; в противном случае вывести адрес первой вершины (в инфиксном порядке), нарушающей требуемую закономерность. </p>
<p class="ptTask"><span class="ptSpecial">GCTree58</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Если данное дерево является <i>деревом поиска без повторяющихся элементов</i>, т.&nbsp;е. если при обходе его вершин в инфиксном порядке их значения образуют возрастающую последовательность, то вывести nil; в противном случае вывести адрес первой вершины (в инфиксном порядке), нарушающей требуемую закономерность. </p>
<p class="ptTask"><span class="ptSpecial">GCTree59°</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева поиска без повторяющихся элементов и число&nbsp;<i>K</i>. Определить, содержит ли исходное дерево вершину со значением&nbsp;<i>K</i>. Если содержит, то вывести ссылку <i>A</i><sub>2</sub> на эту вершину, в противном случае вывести nil. Вывести также количество&nbsp;<i>N</i> вершин, которые потребовалось проанализировать для выполнения задания. </p>
<p class="ptTask"><span class="ptSpecial">GCTree60</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева поиска и число&nbsp;<i>K</i>. Вывести количество&nbsp;<i>C</i> вершин исходного дерева, имеющих значение&nbsp;<i>K</i>, а также количество&nbsp;<i>N</i> вершин, которые потребовалось проанализировать для выполнения задания. </p>
<p class="ptTask"><span class="ptSpecial">GCTree61</span>. Дан корень <i>A</i><sub>1</sub> дерева поиска (если дерево является пустым, то <i>A</i><sub>1</sub>&nbsp;=&nbsp;nil). Также дано число&nbsp;<i>K</i>. Добавить к исходному дереву поиска новую вершину со значением&nbsp;<i>K</i> таким образом, чтобы полученное дерево осталось деревом поиска, и вывести ссылку <i>A</i><sub>2</sub> на корень полученного дерева. Использовать следующий рекурсивный алгоритм для дерева с корнем&nbsp;<i>A</i>: если <i>A</i>&nbsp;=&nbsp;nil, то создать лист со значением&nbsp;<i>K</i> и присвоить объекту&nbsp;<i>A</i> ссылку на созданный лист; если корень&nbsp;<i>A</i> существует, то в случае, если его значение больше&nbsp;<i>K</i>, выполнить алгоритм для свойства Left корня&nbsp;<i>A</i>, иначе выполнить алгоритм для его свойства Right. </p>
<p class="ptTask"><span class="ptSpecial">GCTree62</span>. Дан корень <i>A</i><sub>1</sub> дерева поиска без повторяющихся элементов (если дерево является пустым, то <i>A</i><sub>1</sub>&nbsp;=&nbsp;nil). Также дано число&nbsp;<i>K</i>. Добавить к исходному дереву поиска новую вершину со значением&nbsp;<i>K</i> таким образом, чтобы полученное дерево осталось деревом поиска без повторяющихся элементов, и вывести ссылку&nbsp;<i>A</i><sub>2</sub> на корень полученного дерева. Если исходное дерево уже содержит вершину со значением&nbsp;<i>K</i>, то оставить дерево без изменений. Использовать следующий рекурсивный алгоритм для дерева с корнем&nbsp;<i>A</i>: если <i>A</i>&nbsp;=&nbsp;nil, то создать лист со значением&nbsp;<i>K</i> и присвоить объекту&nbsp;<i>A</i> ссылку на созданный лист; если корень&nbsp;<i>A</i> существует, то в случае, если его значение больше&nbsp;<i>K</i>, выполнить алгоритм для свойства Left корня&nbsp;<i>A</i>, а в случае, если его значение меньше&nbsp;<i>K</i>, выполнить алгоритм для его свойства Right. </p>
<p class="ptTask"><span class="ptSpecial">GCTree63</span>. Дано число&nbsp;<i>N</i> (&gt;&nbsp;0) и набор из <i>N</i>&nbsp;чисел, а также корень <i>A</i><sub>1</sub> дерева поиска (если дерево является пустым, то <i>A</i><sub>1</sub>&nbsp;=&nbsp;nil). Добавить к исходному дереву поиска <i>N</i>&nbsp;новых вершин со значениями из исходного набора таким образом, чтобы полученное дерево осталось деревом поиска, и вывести ссылку&nbsp;<i>A</i><sub>2</sub> на корень полученного дерева. Для добавления новых вершин использовать алгоритм, описанный в задании GCTree61. </p>
<p class="ptTask"><span class="ptSpecial">GCTree64</span>. Дано число&nbsp;<i>N</i> (&gt;&nbsp;0) и набор из <i>N</i>&nbsp;чисел, а также корень <i>A</i><sub>1</sub> дерева поиска без повторяющихся элементов (если дерево является пустым, то <i>A</i><sub>1</sub>&nbsp;=&nbsp;nil). Добавить к исходному дереву поиска новые вершины со значениями из исходного набора таким образом, чтобы полученное дерево осталось деревом поиска без повторяющихся элементов, и вывести ссылку&nbsp;<i>A</i><sub>2</sub> на корень полученного дерева. Для добавления новых вершин использовать алгоритм, описанный в задании GCTree62. </p>
<p class="ptTask"><span class="ptSpecial">GCTree65°</span>. Дано число&nbsp;<i>N</i> (&gt;&nbsp;0) и набор из <i>N</i>&nbsp;чисел. Отсортировать исходный набор чисел, создав для него дерево поиска (алгоритм добавления вершин к дереву поиска описан в задании GCTree61). Вывести ссылку&nbsp;<i>A</i><sub>1</sub> на корень полученного дерева, а также отсортированный набор чисел (для вывода набора чисел выполнить перебор вершин дерева в инфиксном порядке). </p>
<p class="ptTask"><span class="ptSpecial">GCTree66</span>. Дано число&nbsp;<i>N</i> (&gt;&nbsp;0) и набор из <i>N</i>&nbsp;чисел. Получить отсортированный набор исходных чисел без повторений, создав для исходного набора дерево поиска без повторяющихся элементов (алгоритм добавления вершин к подобному дереву описан в задании GCTree62). Вывести ссылку <i>A</i><sub>1</sub> на корень полученного дерева, а также отсортированный набор чисел без повторений (для вывода набора чисел выполнить перебор вершин дерева в инфиксном порядке). </p>
<p class="ptTask"><span class="ptSpecial">GCTree67</span>. Даны две ссылки: <i>A</i><sub>1</sub> на корень непустого дерева поиска и <i>A</i><sub>2</sub> на одну из вершин этого дерева, имеющих не более одной дочерней вершины. Удалить из исходного дерева вершину <i>A</i><sub>2</sub> так, чтобы полученное дерево осталось деревом поиска (если удаляемая вершина <i>A</i><sub>2</sub> имеет дочернюю вершину, то эту дочернюю вершину необходимо связать с родительской вершиной вершины <i>A</i><sub>2</sub>). Вывести ссылку <i>A</i><sub>3</sub> на корень полученного дерева или nil, если в результате удаления вершины <i>A</i><sub>2</sub> дерево стало пустым. </p>
<p class="ptTask"><span class="ptSpecial">GCTree68</span>. Даны два ссылки: <i>A</i><sub>1</sub> на корень непустого дерева поиска и <i>A</i><sub>2</sub> на одну из вершин этого дерева, имеющих две дочерние вершины. Удалить из исходного дерева вершину <i>A</i><sub>2</sub> так, чтобы полученное дерево осталось деревом поиска. Удаление выполнять следующим образом: в левом поддереве вершины <i>A</i><sub>2</sub> найти вершину&nbsp;<i>A</i> с наибольшим значением, присвоить это наибольшее значение вершине <i>A</i><sub>2</sub>, после чего удалить вершину&nbsp;<i>A</i>, действуя, как в задании GCTree67 (поскольку вершина&nbsp;<i>A</i> будет иметь не более одной дочерней вершины). </p>
<p class="ptTask"><span class="ptSpecial">GCTree69</span>. Даны два ссылки: <i>A</i><sub>1</sub> на корень непустого дерева поиска и <i>A</i><sub>2</sub> на одну из вершин этого дерева, имеющих две дочерние вершины. Удалить из исходного дерева вершину <i>A</i><sub>2</sub> так, чтобы полученное дерево осталось деревом поиска. Удаление выполнять следующим образом: в правом поддереве вершины <i>A</i><sub>2</sub> найти вершину&nbsp;<i>A</i> с наименьшим значением, присвоить это наименьшее значение вершине <i>A</i><sub>2</sub>, после чего удалить вершину&nbsp;<i>A</i>, действуя, как в задании GCTree67 (поскольку вершина&nbsp;<i>A</i> будет иметь не более одной дочерней вершины). </p>
<p class="ptTask"><span class="ptSpecial">GCTree70°</span>. Дана ссылка <i>A</i><sub>1</sub> на одну из вершин непустого дерева поиска с обратной связью. Удалить из исходного дерева вершину&nbsp;<i>A</i><sub>1</sub> таким образом, чтобы полученное дерево осталось деревом поиска с обратной связью, и вывести ссылку&nbsp;<i>A</i><sub>2</sub> на корень полученного дерева или nil, если в результате удаления дерево стало пустым. Если вершина <i>A</i><sub>1</sub> имеет две дочерние вершины, то для ее удаления использовать алгоритм, описанный в задании GCTree68. </p>
<p class="ptTask"><span class="ptSpecial">GCTree71</span>. Дана ссылка <i>A</i><sub>1</sub> на одну из вершин непустого дерева поиска с обратной связью. Удалить из исходного дерева вершину&nbsp;<i>A</i><sub>1</sub> таким образом, чтобы полученное дерево осталось деревом поиска с обратной связью, и вывести ссылку&nbsp;<i>A</i><sub>2</sub> на корень полученного дерева или nil, если в результате удаления дерево стало пустым. Если вершина <i>A</i><sub>1</sub> имеет две дочерние вершины, то для ее удаления использовать алгоритм, описанный в задании GCTree69. </p>
<h2>Бинарные деревья разбора выражений</h2>
<p class="ptTask"><span class="ptSpecial">GCTree72</span>. Дана строка <i>S</i>, содержащая описание непустого дерева в следующем формате: </p><p class="ptTaskCenter"><table align="center"><tr><td align=left>&lt;дерево&gt;<td align=center><tt>::=</tt> <td align=left>&lt;пусто&gt; | <tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>&lt;вершина&gt;(&lt;левое поддерево&gt;,&lt;правое поддерево&gt;)<tr><td align=left>&lt;вершина&gt;<td align=center><tt>::=</tt> <td align=left>&lt;цифра&gt;</table></p><p class="ptTaskContinue">Например, &#171;4(2(,),6(,7(3(,),)))&#187; (пробелы отсутствуют). Создать дерево по описанию, приведенному в&nbsp;<i>S</i>, и вывести ссылку на его корень. </p>
<p class="ptTask"><span class="ptSpecial">GCTree73</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Вывести строку с описанием исходного дерева в формате, приведенном в задании GCTree72. </p>
<p class="ptTask"><span class="ptSpecial">GCTree74°</span>. Дана строка <i>S</i>, содержащая описание непустого дерева в следующем формате: </p><p class="ptTaskCenter"><table align="center"><tr><td align=left>&lt;дерево&gt;<td align=center><tt>::=</tt> <td align=left>&lt;вершина&gt; | <tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>&lt;вершина&gt;(&lt;левое поддерево&gt;,&lt;правое поддерево&gt;) | <tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>&lt;вершина&gt;(&lt;левое поддерево&gt;) | <tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>&lt;вершина&gt;(,&lt;правое поддерево&gt;)<tr><td align=left>&lt;вершина&gt;<td align=center><tt>::=</tt> <td align=left>&lt;цифра&gt;</table></p><p class="ptTaskContinue">Например, &#171;4(2,6(,7(3)))&#187; (пробелы отсутствуют, вид описания вершины зависит от того, имеет ли вершина непустое левое и/или правое поддерево). Создать дерево по описанию, приведенному в&nbsp;<i>S</i>, и вывести ссылку на его корень. </p>
<p class="ptTask"><span class="ptSpecial">GCTree75°</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева. Вывести строку с описанием исходного дерева в формате, приведенном в задании GCTree74. </p>
<p class="ptTask"><span class="ptSpecial">GCTree76°</span>. Дана строка <i>S</i>, содержащая описание числового выражения в следующем формате: </p><p class="ptTaskCenter"><table align="center"><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>&lt;цифра&gt; |<tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>(&lt;выражение&gt;&lt;знак&gt;&lt;выражение&gt;)<tr><td align=left>&lt;знак&gt;      <td align=center><tt>::=</tt> <td align=left>+ | &#8722; | *</table></p><p class="ptTaskContinue">Пробелы в строке отсутствуют. Создать дерево, соответствующее исходному выражению (<i>дерево разбора выражения</i>): каждая внутренняя вершина дерева должна соответствовать одной из трех возможных арифметических операций и иметь значение &#8722;1 для операции сложения, &#8722;2 для операции вычитания и &#8722;3 для операции умножения; левое и правое дочерние поддеревья любой внутренней вершины-операции должны соответствовать выражениям слева и справа от знака операции; листьями полученного дерева должны быть выражения-цифры. Вывести ссылку на корень созданного дерева. </p>
<p class="ptTask"><span class="ptSpecial">GCTree77</span>. Дана строка <i>S</i>, содержащая описание числового выражения в следующем формате (так называемый <i>префиксный бесскобочный формат</i> записи числового выражения): </p><p class="ptTaskCenter"><table align="center"><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>&lt;цифра&gt; |<tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>&lt;знак&gt; &lt;выражение&gt; &lt;выражение&gt;<tr><td align=left>&lt;знак&gt;      <td align=center><tt>::=</tt> <td align=left>+ | &#8722; | *</table></p><p class="ptTaskContinue">Выражения отделяются друг от друга и от знаков операций ровно одним пробелом. Создать дерево разбора выражения и вывести ссылку на его корень. Структура дерева разбора выражения описана в задании GCTree76; для каждой вершины-операции ее левое поддерево должно соответствовать первому операнду данной операции, а правое поддерево &#8212; второму. </p>
<p class="ptTask"><span class="ptSpecial">GCTree78</span>. Дана строка <i>S</i>, содержащая описание числового выражения в следующем формате (так называемый <i>постфиксный бесскобочный формат</i> записи числового выражения): </p><p class="ptTaskCenter"><table align="center"><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>&lt;цифра&gt; |<tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>&lt;выражение&gt; &lt;выражение&gt; &lt;знак&gt;<tr><td align=left>&lt;знак&gt;      <td align=center><tt>::=</tt> <td align=left>+ | &#8722; | *</table></p><p class="ptTaskContinue">Выражения отделяются друг от друга и от знаков операций ровно одним пробелом. Создать дерево разбора выражения и вывести ссылку на его корень. Структура дерева разбора выражения описана в задании GCTree76; для каждой вершины-операции ее левое поддерево должно соответствовать первому операнду данной операции, а правое поддерево &#8212; второму. </p>
<p class="ptTask"><span class="ptSpecial">GCTree79°</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева разбора выражения (структура дерева описана в задании GCTree76). Вывести значение выражения, определяемого исходным деревом. </p>
<p class="ptTask"><span class="ptSpecial">GCTree80</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева разбора выражения (структура дерева описана в задании GCTree76). Вывести строковое представление соответствующего выражения в формате, приведенном в том же задании: </p><p class="ptTaskCenter"><table align="center"><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>&lt;цифра&gt; |<tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>(&lt;выражение&gt;&lt;знак&gt;&lt;выражение&gt;)<tr><td align=left>&lt;знак&gt;      <td align=center><tt>::=</tt> <td align=left>+ | &#8722; | *</table></p>
<p class="ptTask"><span class="ptSpecial">GCTree81</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева разбора выражения. Вывести строковое представление соответствующего выражения в префиксном бесскобочном формате (см. задание GCTree77). </p>
<p class="ptTask"><span class="ptSpecial">GCTree82</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева разбора выражения. Вывести строковое представление соответствующего выражения в постфиксном бесскобочном формате (см. задание GCTree78). </p>
<p class="ptTask"><span class="ptSpecial">GCTree83</span>. Дана строка <i>S</i>, содержащая описание числового выражения в следующем формате (функция&nbsp;M возвращает максимальное из двух выражений, а m &#8212; минимальное): </p><p class="ptTaskCenter"><table align="center"><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>&lt;цифра&gt; | M(&lt;выражение&gt;&nbsp;,&nbsp;&lt;выражение&gt;) | <tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>m(&lt;выражение&gt;&nbsp;,&nbsp;&lt;выражение&gt;)</table></p><p class="ptTaskContinue">Пробелы в строке отсутствуют. Создать дерево разбора исходного выражения: каждая внутренняя вершина дерева должна соответствовать одной из двух возможных функций и иметь значение &#8722;1 для функции M и &#8722;2 для функции m; для каждой вершины-функции ее левое поддерево должно соответствовать первому аргументу функции, а правое поддерево &#8212; второму; листьями полученного дерева должны быть выражения-цифры. Вывести ссылку на корень созданного дерева. </p>
<p class="ptTask"><span class="ptSpecial">GCTree84</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева разбора выражения (структура дерева описана в задании GCTree83). Вывести значение выражения, определяемого исходным деревом. </p>
<p class="ptTask"><span class="ptSpecial">GCTree85</span>. Дан корень <i>A</i><sub>1</sub> непустого дерева разбора выражения (структура дерева описана в задании GCTree83). Вывести строковое представление соответствующего выражения в формате, приведенном в том же задании: </p><p class="ptTaskCenter"><table align="center"><tr><td align=left>&lt;выражение&gt; <td align=center><tt>::=</tt> <td align=left>&lt;цифра&gt; | M(&lt;выражение&gt;&nbsp;,&nbsp;&lt;выражение&gt;) | <tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>m(&lt;выражение&gt;&nbsp;,&nbsp;&lt;выражение&gt;)</table></p>
<h2>Деревья общего вида</h2>
<p class="ptTask"><span class="ptSpecial">GCTree86°</span>. <i>Дерево общего вида</i> (каждая вершина которого может иметь произвольное число дочерних вершин, расположенных в фиксированном порядке в направлении слева направо) реализуется с помощью набора связанных объектов типа Node следующим образом: для каждой внутренней вершины ее свойство Left содержит ссылку на ее первую (т.&nbsp;е. левую) дочернюю вершину, а свойство Right&nbsp;&#8212; ссылку на ее правую <i>сестру</i>, т.&nbsp;е. вершину, имеющую в дереве общего вида того же родителя. Свойство Right корня дерева общего вида всегда равно nil, так как корень сестер не имеет. Дан корень&nbsp;<i>A</i><sub>1</sub> непустого бинарного дерева. Создать дерево общего вида, соответствующее исходному бинарному дереву, и вывести ссылку&nbsp;<i>A</i><sub>2</sub> на его корень. </p>
<p class="ptTask"><span class="ptSpecial">GCTree87</span>. Дан корень&nbsp;<i>A</i><sub>1</sub> непустого дерева общего вида. Любая вершина исходного дерева имеет не более двух дочерних вершин. Создать бинарное дерево, соответствующее исходному дереву общего вида, и вывести ссылку&nbsp;<i>A</i><sub>2</sub> на его корень. Считать, что первая дочерняя вершина любой вершины дерева общего вида соответствует левой дочерней вершине в бинарном дереве. </p>
<p class="ptTask"><span class="ptSpecial">GCTree88</span>. Дан корень&nbsp;<i>A</i><sub>1</sub> непустого дерева общего вида. Вывести <i>глубину</i> данного дерева, т.&nbsp;е. значение его максимального уровня, считая, что все вершины-сестры находятся на одном уровне, а корень дерева расположен на уровне&nbsp;0. </p>
<p class="ptTask"><span class="ptSpecial">GCTree89</span>. Дан корень&nbsp;<i>A</i><sub>1</sub> непустого дерева общего вида. Для каждого из уровней данного дерева, начиная с уровня&nbsp;0, вывести количество вершин, находящихся на этом уровне. Считать, что глубина исходного дерева общего вида не превосходит&nbsp;10. </p>
<p class="ptTask"><span class="ptSpecial">GCTree90</span>. Дан корень&nbsp;<i>A</i><sub>1</sub> непустого дерева общего вида. Для каждого из уровней данного дерева, начиная с уровня&nbsp;0, вывести сумму значений вершин, находящихся на этом уровне. Считать, что глубина исходного дерева общего вида не превосходит&nbsp;10. </p>
<p class="ptTask"><span class="ptSpecial">GCTree91</span>. Дан корень&nbsp;<i>A</i><sub>1</sub> непустого дерева общего вида. Также дано неотрицательное число&nbsp;<i>L</i>. Перебирая дочерние вершины в заданном порядке (т.&nbsp;е. слева направо), вывести значения всех вершин уровня&nbsp;<i>L</i> и их количество&nbsp;<i>N</i>. Если дерево не содержит вершин уровня&nbsp;<i>L</i>, то вывести&nbsp;0. </p>
<p class="ptTask"><span class="ptSpecial">GCTree92°</span>. Дан корень&nbsp;<i>A</i><sub>1</sub> непустого дерева общего вида. Вывести значения всех вершин дерева в <i>инфиксном порядке</i>: вначале выводится содержимое первого (левого) поддерева в инфиксном порядке, затем выводится значение корня, а затем &#8212; содержимое остальных поддеревьев в инфиксном порядке (поддеревья перебираются слева направо). </p>
<p class="ptTask"><span class="ptSpecial">GCTree93</span>. Дан корень&nbsp;<i>A</i><sub>1</sub> непустого дерева общего вида. Вывести значения всех вершин дерева в <i>постфиксном порядке</i>: вначале выводится содержимое каждого поддерева в постфиксном порядке (поддеревья перебираются слева направо), а затем&nbsp;&#8212; значение корня. </p>
<p class="ptTask"><span class="ptSpecial">GCTree94</span>. Дан корень&nbsp;<i>A</i><sub>1</sub> непустого дерева общего вида. Также дано неотрицательное число&nbsp;<i>N</i>. Вывести количество вершин исходного дерева, имеющих ровно <i>N</i>&nbsp;дочерних вершин. Если требуемые вершины отсутствуют, то вывести&nbsp;0. </p>
<p class="ptTask"><span class="ptSpecial">GCTree95</span>. Дан корень&nbsp;<i>A</i><sub>1</sub> непустого дерева общего вида. Вывести ссылку&nbsp;<i>A</i><sub>2</sub> на первую вершину дерева, имеющую наибольшее количество дочерних вершин. Вершины перебирать в инфиксном порядке (см. задание GCTree92). </p>
<p class="ptTask"><span class="ptSpecial">GCTree96</span>. Дан корень&nbsp;<i>A</i><sub>1</sub> непустого дерева общего вида. Вывести ссылку&nbsp;<i>A</i><sub>2</sub> на последнюю вершину дерева с наибольшей суммой значений дочерних вершин. Вершины перебирать в постфиксном порядке (см. задание GCTree93). </p>
<p class="ptTask"><span class="ptSpecial">GCTree97</span>. Дан корень&nbsp;<i>A</i><sub>1</sub> непустого дерева общего вида. В каждом наборе вершин-сестер заменить все значения вершин (т.&nbsp;е. значения свойств Data) на максимальное из их исходных значений. </p>
<p class="ptTask"><span class="ptSpecial">GCTree98</span>. Дан корень&nbsp;<i>A</i><sub>1</sub> непустого дерева общего вида. В каждом наборе вершин-сестер изменить порядок следования их значений на противоположный, т.&nbsp;е. поменять местами значения свойства Data первой (левой) и последней (правой) сестры, второй и предпоследней сестры, и т.&nbsp;д. </p>
<p class="ptTask"><span class="ptSpecial">GCTree99</span>. Дана строка&nbsp;<i>S</i>, содержащая описание непустого дерева общего вида в следующем формате: </p><p class="ptTaskCenter"><table align="center"><tr><td align=left>&lt;дерево&gt;<td align=center><tt>::=</tt> <td align=left>&lt;вершина&gt; | <tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>&lt;вершина&gt;(&lt;список поддеревьев&gt;)<tr><td align=left>&lt;список поддеревьев&gt;<td align=center><tt>::=</tt> <td align=left>&lt;дерево&gt; | <tr><td align=left>&nbsp;<td align=center>&nbsp;<td align=left>&lt;дерево&gt;,&lt;список поддеревьев&gt;<tr><td align=left>&lt;вершина&gt;<td align=center><tt>::=</tt> <td align=left>&lt;цифра&gt;</table></p><p class="ptTaskContinue">Например, &#171;3(2,7(6,4,5),8(4(2,3),5(1)))&#187; (пробелы отсутствуют, вершины-сестры перечисляются в порядке слева направо). Создать дерево общего вида по описанию, приведенному в&nbsp;<i>S</i>, и вывести ссылку на его корень. </p>
<p class="ptTask"><span class="ptSpecial">GCTree100</span>. Дан корень&nbsp;<i>A</i><sub>1</sub> непустого дерева общего вида. Вывести строку с описанием исходного дерева в формате, приведенном в задании GCTree99. </p>
<hr noshade>
<p class="ptFooter">Дата генерации страницы: 11.02.2017.</p>
</body></html>
